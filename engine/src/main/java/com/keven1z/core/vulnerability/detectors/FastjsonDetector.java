package com.keven1z.core.vulnerability.detectors;

import com.keven1z.core.consts.VulnerabilityLevel;
import com.keven1z.core.consts.VulnerabilityType;
import com.keven1z.core.model.graph.TaintData;
import com.keven1z.core.utils.ReflectionUtils;
import com.keven1z.core.vulnerability.AbstractDetector;
import com.keven1z.core.vulnerability.DetectContext;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class FastjsonDetector extends AbstractDetector {
    // 定义最低安全版本（参考官方建议）
    private static final String MIN_SAFE_VERSION = "1.2.83";

    public FastjsonDetector() {
        super(VulnerabilityType.FASTJSON, VulnerabilityLevel.CRITICAL);
    }


    @Override
    public boolean detect(DetectContext context) {
        TaintData sinkTaintData = context.getFlowLinks().getLast();
        Object sinkObject = sinkTaintData.getThisObject();
        String version = getFastjsonVersion(sinkObject);
        if ("UNKNOWN".equals(version)) {
            return true; // 无法确认版本时默认视为不安全
        }
        return compareVersions(version, MIN_SAFE_VERSION) < 0;
    }


    // 获取版本号
    private static String getFastjsonVersion(Object jsonObject) {
        try {
            return (String)ReflectionUtils.getField(jsonObject, "VERSION");
        } catch (Exception e) {
            return "UNKNOWN";
        }
    }

    // 语义化版本比较（支持 1.2.83.sec10 格式）
    private static int compareVersions(String v1, String v2) {
        // 提取主版本号（忽略后缀）
        String[] parts1 = v1.split("[-_]");
        String[] parts2 = v2.split("[-_]");

        // 分割数字部分
        int[] nums1 = parseVersionParts(parts1[0]);
        int[] nums2 = parseVersionParts(parts2[0]);

        int maxLength = Math.max(nums1.length, nums2.length);
        for (int i = 0; i < maxLength; i++) {
            int num1 = (i < nums1.length) ? nums1[i] : 0;
            int num2 = (i < nums2.length) ? nums2[i] : 0;
            if (num1 != num2) {
                return Integer.compare(num1, num2);
            }
        }
        return 0;
    }

    // 解析版本号段
    private static int[] parseVersionParts(String version) {
        Pattern pattern = Pattern.compile("\\d+");
        Matcher matcher = pattern.matcher(version);
        List<Integer> parts = new ArrayList<>();
        while (matcher.find()) {
            parts.add(Integer.parseInt(matcher.group()));
        }
        return parts.stream().mapToInt(i -> i).toArray();
    }
}
