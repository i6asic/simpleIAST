package com.keven1z.core.vulnerability;

import com.keven1z.core.consts.VulnerabilityType;
import com.keven1z.core.hook.http.request.AbstractRequest;
import com.keven1z.core.hook.http.response.HttpServletResponse;
import com.keven1z.core.log.LogTool;
import com.keven1z.core.model.ApplicationModel;
import com.keven1z.core.model.finding.FindingData;
import com.keven1z.core.model.finding.FindingReportBo;
import com.keven1z.core.model.server.HttpRequestData;
import com.keven1z.core.model.server.HttpResponseData;
import com.keven1z.core.vulnerability.detectors.*;
import org.apache.log4j.Logger;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

import static com.keven1z.core.hook.HookThreadLocal.*;

/**
 * @author keven1z
 * @since 2023/10/29
 * hook以及流量处理类
 */
public class DetectorFactory {
    private static final Logger logger = Logger.getLogger(DetectorFactory.class);
    // 注册表
    private final Map<VulnerabilityType, Detector> detectorRegistry = new ConcurrentHashMap<>();

    private DetectorFactory() {
        registerDefaultDetectors();
    }
    /**
     * 注册自定义检测器
     *
     * @param type 检测类型
     * @param detector 检测器实例
     * @throws IllegalArgumentException 当类型冲突时抛出
     */
    public void registerDetector(VulnerabilityType type, Detector detector) {
        Objects.requireNonNull(type, "DetectType cannot be null");
        Objects.requireNonNull(detector, "Detector instance cannot be null");

        if (detectorRegistry.containsKey(type)) {
            throw new IllegalArgumentException("Detector type already registered: " + type);
        }
        detectorRegistry.put(type, detector);
    }
    private void registerDefaultDetectors() {
        registerDetector(VulnerabilityType.SSRF,new SSRFDetector());
        registerDetector(VulnerabilityType.SQL_INJECTION,new SqliDetector());
        registerDetector(VulnerabilityType.XXE,new XxeDetector());
        registerDetector(VulnerabilityType.CMD_INJECTION,new CmdiDetector());
        registerDetector(VulnerabilityType.DESERIALIZATION,new DeserializationDetector());
        registerDetector(VulnerabilityType.URL_REDIRECT,new UrlRedirectDetector());
        registerDetector(VulnerabilityType.XSS,new XSSDetector());
        registerDetector(VulnerabilityType.Path_Traversal,new PathTraversalDetector());
        registerDetector(VulnerabilityType.FILE_UPLOAD,new FileUploadDetector());
        registerDetector(VulnerabilityType.SPRING_EXPRESSION_INJECTION,new SpelDetector());
        registerDetector(VulnerabilityType.XPATH_INJECTION,new XpathDetector());
        registerDetector(VulnerabilityType.FASTJSON,new FastjsonDetector());
        registerDetector(VulnerabilityType.WEAK_PASSWORD_IN_POST,new WeakPasswordInPOSTDetector());
        registerDetector(VulnerabilityType.WEAK_PASSWORD_IN_SQL,new WeakPasswordInSqlDetector());
    }
    public static DetectorFactory getInstance() {
        return Inner.DETECTOR_FACTORY;
    }

    private static class Inner {
        private static final DetectorFactory DETECTOR_FACTORY = new DetectorFactory();
    }

    public void processAndReportFindings() {

        if (SINGLE_FINDING_THREADLOCAL.get() == null || TAINT_GRAPH_THREAD_LOCAL.get() == null) {
            logger.error("ThreadLocal data is null.");
            return;
        }

        if (SINGLE_FINDING_THREADLOCAL.get().isEmpty() && TAINT_GRAPH_THREAD_LOCAL.get().getSinkNodes().isEmpty()) {
            if (LogTool.isDebugEnabled()) {
                logger.info("Not found any sink node,url:" + REQUEST_THREAD_LOCAL.get().getRequest().getRequestURL());
            }
            return;
        }

        List<FindingData> findingDataList = new ArrayList<>(SINGLE_FINDING_THREADLOCAL.get());

        FindingReportBo findingReportBo = prepareFindingReport(findingDataList);
        boolean isOffer = FINDING_REPORT_QUEUE.offer(findingReportBo);
        if (!isOffer) {
            logger.warn("Finding report queue is full. Report was not added.");
        }
    }
    /**
     * 准备发现漏洞报告业务对象
     *
     * @param findingDataList 发现的数据列表
     * @return 包含请求数据、响应数据、单个发现数据列表和污染图的 {@link FindingReportBo} 对象
     */
    private FindingReportBo prepareFindingReport(List<FindingData> findingDataList) {
        FindingReportBo findingReportBo = new FindingReportBo(ApplicationModel.getAgentId());
        findingReportBo.setRequestData(buildRequest());
        findingReportBo.setResponseData(buildResponse());
        findingReportBo.setSingleFindingDataList(findingDataList);
        findingReportBo.setTaintGraph(TAINT_GRAPH_THREAD_LOCAL.get());
        return findingReportBo;
    }

    /**
     * 获取检测器
     *
     * @param type 检测类型枚举
     * @return 可能返回null（当类型未注册时）
     */
    public Detector getDetector(VulnerabilityType type) {
        return detectorRegistry.get(type);
    }
    /**
     * 获取所有已注册类型
     */
    public Iterable<VulnerabilityType> getRegisteredTypes() {
        return detectorRegistry.keySet();
    }
    /**
     * 热更新检测器
     */
    public synchronized void reloadDetector(VulnerabilityType type, Detector newDetector) {
        detectorRegistry.put(type, newDetector);
    }
    /**
     * 清空注册表（测试专用，生产环境禁止使用）
     */
    void clearRegistry() {
        detectorRegistry.clear();
    }

    /**
     * 构建http请求
     */
    private HttpRequestData buildRequest() {
        AbstractRequest request = REQUEST_THREAD_LOCAL.get().getRequest();
        HttpRequestData httpRequestData = new HttpRequestData(request.getRequestURLString(), request.getMethod(), request.getHeaders());
        httpRequestData.setRequestBody(request.getStringBody());
        httpRequestData.setUri(request.getRequestURI());
        httpRequestData.setProtocol(request.getProtocol());
        return httpRequestData;
    }

    private HttpResponseData buildResponse() {
        HttpServletResponse response = REQUEST_THREAD_LOCAL.get().getResponse();
        HttpResponseData httpResponseData = new HttpResponseData(response.getHeaders());
        httpResponseData.setStatusCode(response.getStatusCode());
        return httpResponseData;
    }
}
